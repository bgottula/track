#!/usr/bin/env python3

"""Perform automated alignment with Gemini 2 mounts.

This program automates the somewhat tedious process of aligning the mount. For the selected
meridian side it will select a bright star, slew the mount to the vicinity of that star, use the
guidscope camera to center on that star, and send commands to Gemini 2 to add the star to the
alignment model (or to synchronize in the case of the first star). This process is repeated until
the desired number of stars have been added to the model or the program runs out of usable stars.
"""

import math
import time
import numpy as np
from astropy_healpix import HEALPix
from astropy import units as u
from astropy.time import Time
from astropy.coordinates import SkyCoord, EarthLocation, AltAz
from astroplan import Observer
import cv2
import asi
import track


def alt_from_ha_dec(ha, dec, mount_pole_altitude):
    """Get the approximate altitude of a target specified with a local hour angle and declination.

    Args:
        ha: Target local hour angle as an astropy Angle object.
        dec: Target declination as an astropy Angle object.
        mount_pole_altitude: Altitude of the mount's pole in degrees above the horizon.

    Returns:
        The altitude of the target as an astropy Angle object.
    """

    # This is a fake location required in order to determine the altitude of each HEALPix pixel.
    # In these conversions, which only need to be approximate, the longitude and elevation of the
    # observer don't matter. The "latitude" is set to the altitude of the mount's pole since our
    # HEALPix hour angles and declinations are relative to the mount's pole location and not the
    # celestial pole.
    location = EarthLocation(lat=mount_pole_altitude*u.deg, lon=0*u.deg, height=0*u.m)

    # The time should be relatively unimportant for these calculations; it is only necessary
    # because astropy does not provide a direct transformation between local coordinates given as
    # hour angle / declination and local coordinates in azimuth / altitude format. Therefore, we
    # must transform first to equatorial coordinates (right ascension / declination) before
    # converting finally to azimuth / altitude.
    t = Time(time.time(), format='unix', location=location)
    st = t.sidereal_time('mean')
    ra = st - ha
    me = Observer(location=location)
    sc = SkyCoord(ra, dec, frame='icrs')
    return me.altaz(t, target=sc).alt

def generate_positions(min_positions, mount_pole_altitude, min_altitude=0.0, meridian_side=None):
    """Generate a list of equally spaced positions on one hemisphere of the sky to search.

    The list of positions generated will be a subset of pixels generated by the HEALPix algorithm,
    which is a method of pixelization of a sphere where each "pixel" has equal area. In the
    context of mount alignment we not so much concerned with the equal area property, but we do
    want positions that are roughly evenly distributed over the sphere, and HEALPix does a
    reasonable job of this as well. The full set of HEALPix pixels is filtered to exclude pixels
    that are below a minimum altitude threshold and those that are on the opposite side of the
    meridian. HEALPix is oriented with the top co-located with the pole of the mount.

    Args:
        min_positions: Minimum number of positions. The actual number of positions returned may be
            larger than requested.
        mount_pole_altitude: Altitude of the mount's pole in degrees. For a German equatorial
            mount in the Northern hemisphere this is usually equal to the current latitude, however
            this is not required.
        min_altitude: Restrict positions to be above this altitude in degrees.
        meridian_side: A string, 'east' or 'west', or None. If specified, restricts positions to
            only be on this side of the meridian.

    Returns:
        A list of dicts with keys 'ha' and 'dec' giving hour angles and declinations in degrees.
            Since this is used for alignment and no assumptions are made about the orientation
            of the mount, particularly the location of the mount's pole, these coordinates are
            interpreted with respect to the mount's startup position. In other words, declination
            0 means the optical tube is pointed towards the mount's physical pole, and not
            necessarily towards Polaris. Similarly, hour angle 0 means that the counter weight is
            pointed down, and this does not necessarily correspond to the great circle passing
            through the local zenith and the celestial pole.
    """
    level = 0
    while True:
        healpix = HEALPix(nside=2**level)
        positions = []
        for i in range(healpix.npix):

            # interpret each HEALPix as an hour angle and declination coordinate
            (ha, dec) = healpix.healpix_to_lonlat(i)

            # skip points on wrong side of meridian
            if ha.deg <= 180.0 and meridian_side == 'east':
                continue
            elif ha.deg > 180.0 and meridian_side == 'west':
                continue

            # skip points below min altitude threshold
            alt = alt_from_ha_dec(ha, dec, mount_pole_altitude)
            if alt.deg < min_altitude:
                continue

            positions.append({'ha': ha.deg, 'dec': dec.deg})

        if len(positions) >= min_positions:
            break

        # try again with a higher level HEALPix
        level += 1

    return positions

def asi_check(return_values):
    """Check return values from ASICamera2 API calls for errors.

    Args:
        return_values: The return value or values from a ASICamera2 API call.

    Returns:
        The return_values but with the status code removed. If the status code was the only return
        value from the API call, this function returns None.

    Raises:
        RuntimeError if the status code was something other than ASI_SUCCESS.
    """
    if isinstance(return_values, (tuple, list)):
        status_code = return_values[0]
        return_values = return_values[1:] if len(return_values) > 2 else return_values[1]
    else:
        status_code = return_values
        return_values = None

    if status_code != asi.ASI_SUCCESS:
        raise RuntimeError('return code: {}'.format(status_code))

    return return_values

def camera_setup(gain, exposure_time, binning):
    if asi.ASIGetNumOfConnectedCameras() == 0:
        raise RuntimeError('No cameras connected')
    info = asi_check(asi.ASIGetCameraProperty(0))
    width = info.MaxWidth // binning
    height = info.MaxHeight // binning
    frame_size = width * height * 2
    asi_check(asi.ASIOpenCamera(info.CameraID))
    asi_check(asi.ASIInitCamera(info.CameraID))
    asi_check(asi.ASISetROIFormat(
        info.CameraID,
        width,
        height,
        binning,
        asi.ASI_IMG_RAW16
    ))
    asi_check(asi.ASISetControlValue(
        info.CameraID,
        asi.ASI_EXPOSURE,
        int(exposure_time * 1e6),
        asi.ASI_FALSE
    ))
    asi_check(asi.ASISetControlValue(info.CameraID, asi.ASI_GAIN, gain, asi.ASI_FALSE))
    asi_check(asi.ASISetControlValue(info.CameraID, asi.ASI_MONO_BIN, 1, asi.ASI_FALSE))

    return info, width, height, frame_size

def camera_take_exposure(info, width, height, frame_size):
    """Take an exposure with the camera.

    Args:
        info: An ASI_CAMERA_INFO object.
        width: Width of the frame in pixels.
        height: Height of the frame in pixels.
        frame_size: Size of the frame in bytes (not necessarily equal to width*height).

    Returns:
        A numpy array containing a debayered grayscale camera frame.

    Raises:
        RuntimeError if the exposure failed.
    """
    asi_check(asi.ASIStartExposure(info.CameraID, asi.ASI_FALSE))
    while True:
        status = asi_check(asi.ASIGetExpStatus(info.CameraID))
        if status == asi.ASI_EXP_SUCCESS:
            break
        elif status == asi.ASI_EXP_FAILED:
            raise RuntimeError('Exposure failed')
        else:
            time.sleep(0.01)
    frame = asi_check(asi.ASIGetDataAfterExp(info.CameraID, frame_size))
    frame = frame.view(dtype=np.uint16)
    frame = np.reshape(frame, (height, width))
    return cv2.cvtColor(frame, cv2.COLOR_BAYER_BG2GRAY)

def main():

    parser = track.ArgParser()
    parser.add_argument(
        '--camera-res',
        help='guidescope camera resolution in arcseconds per pixel',
        required=True,
        type=float
    )
    parser.add_argument(
        '--exposure-time',
        help='camera exposure time in seconds',
        default=0.5,
        type=float
    )
    parser.add_argument(
        '--gain',
        help='camera gain',
        default=400,
        type=int
    )
    parser.add_argument(
        '--binning',
        help='camera binning',
        default=4,
        type=int
    )
    parser.add_argument(
        '--mount-type',
        help='select mount type (nexstar or gemini)',
        default='gemini'
    )
    parser.add_argument(
        '--mount-path',
        help='serial device node or hostname for mount command interface',
        default='/dev/ttyACM0'
    )
    parser.add_argument(
        '--meridian-side',
        help='side of meridian for equatorial mounts to prefer',
        default='west'
    )
    parser.add_argument(
        '--lat',
        required=True,
        help='latitude of observer (+N)'
    )
    parser.add_argument(
        '--lon',
        required=True,
        help='longitude of observer (+E)'
    )
    parser.add_argument(
        '--elevation',
        required=True,
        help='elevation of observer (m)',
        type=float
    )
    parser.add_argument(
        '--mount-pole-alt',
        required=True,
        help='altitude of mount pole above horizon (deg)',
        type=float
    )
    parser.add_argument(
        '--loop-bw',
        help='control loop bandwidth (Hz)',
        default=0.5,
        type=float
    )
    parser.add_argument(
        '--loop-damping',
        help='control loop damping factor',
        default=2.0,
        type=float
    )
    parser.add_argument(
        '--telem-enable',
        help='enable logging of telemetry to database',
        action='store_true'
    )
    parser.add_argument(
        '--telem-db-host',
        help='hostname of InfluxDB database server',
        default='localhost'
    )
    parser.add_argument(
        '--telem-db-port',
        help='port number of InfluxDB database server',
        default=8086,
        type=int
    )
    parser.add_argument(
        '--telem-period',
        help='telemetry sampling period in seconds',
        default=1.0,
        type=float
    )
    parser.add_argument(
        '--num-positions',
        help='number of positions to add to mount alignment model',
        default=10,
        type=int
    )
    parser.add_argument(
        '--timeout',
        help='max time to wait for mount to converge on a new position',
        default=120.0,
        type=float
    )
    parser.add_argument(
        '--max-tries',
        help='max number of plate solving attempts at each position',
        default=3,
        type=int
    )
    parser.add_argument(
        '--min-alt',
        help='minimum altitude of alignment stars in degrees',
        default=20.0,
        type=float
    )
    parser.add_argument(
        '--laser-ftdi-serial',
        help='serial number of laser pointer FTDI device',
    )
    args = parser.parse_args()

    # This program only supports Gemini mounts
    if args.mount_type == 'gemini':
        mount = track.LosmandyGeminiMount(args.mount_path)
    else:
        print('mount-type not supported: ' + args.mount_type)
        sys.exit(1)

    # Create object with base type ErrorSource
    # No target for now; that will be populated later
    error_source = track.BlindErrorSource(
        mount=mount,
        observer=None,
        target=None,
        meridian_side=args.meridian_side
    )
    telem_sources = {'error_blind': error_source}

    try:
        laser = track.LaserPointer(serial_num=args.laser_ftdi_serial)
    except OSError:
        print('Could not connect to laser pointer FTDI device.')
        laser = None

    try:
        # Create gamepad object and register callback
        game_pad = track.Gamepad(
            left_gain=2.0,  # left stick degrees per second
            right_gain=0.5,  # right stick degrees per second
            int_limit=5.0,  # max correction in degrees for either axis
        )
        game_pad.integrator_mode = True
        if laser is not None:
            game_pad.register_callback('BTN_SOUTH', laser.set)
        telem_sources['gamepad'] = game_pad
        print('Gamepad found and registered.')
    except RuntimeError:
        print('No gamepads found.')

    tracker = track.Tracker(
        mount=mount,
        error_source=error_source,
        loop_bandwidth=args.loop_bw,
        damping_factor=args.loop_damping
    )
    telem_sources['tracker'] = tracker
    tracker.stop_on_timer = True
    tracker.max_run_time = args.timeout
    tracker.stop_when_converged = True
    tracker.converge_max_error_mag = 2.0

    camera_info, frame_width, frame_height, frame_size = camera_setup(
        gain=args.gain,
        exposure_time=args.exposure_time,
        binning=args.binning
    )

    if args.telem_enable:
        telem_logger = track.TelemLogger(
            host=args.telem_db_host,
            port=args.telem_db_port,
            period=args.telem_period,
            sources=telem_sources,
        )
        telem_logger.start()

    positions = generate_positions(
        min_positions=args.num_positions,
        mount_pole_altitude=args.mount_pole_alt,
        min_altitude=args.min_alt,
        meridian_side=args.meridian_side
    )

    try:
        num_solutions = 0
        for position in positions:

            print('Next position: ' + str(position))

            error_source.target = position
            stop_reason = tracker.run()
            mount.safe()
            if stop_reason == 'converged':
                print('Converged on the target position')
            else:
                raise RuntimeError('Unexpected tracker stop reason: "{}"'.format(stop_reason))

            time_before = time.time()
            frame = camera_take_exposure(camera_info, frame_width, frame_height, frame_size)
            time_after = time.time()

            try:
                sc = track.plate_solve(
                    frame,
                    camera_width=(camera_info.MaxWidth * args.camera_res / 3600.0)
                )
            except track.NoSolutionException:
                print('No solution found')
                continue

            num_solutions += 1
            print('Solution found! ' + str(sc))
            print('mount position: ' + str(mount.get_position()))
            print('timestamp before exposure: ' + str(time_before))
            print('timestamp after exposure: ' + str(time_after))

        print('Alignment completed successfully!')

    except RuntimeError as e:
        print(str(e))
        print('Alignment was not completed.')
    except KeyboardInterrupt:
        print('Got CTRL-C, shutting down...')
    except Exception as e:
        print('Unhandled exception: ' + str(e))
        import IPython; IPython.embed()
    finally:
        pass
        # don't rely on destructors to safe mount!
        print('Safing mount...')
        if mount.safe():
            print('Mount safed successfully!')
        else:
            print('Warning: Mount may be in an unsafe state!')

    if args.telem_enable:
        telem_logger.stop()

    try:
        game_pad.stop()
    except:
        pass

if __name__ == "__main__":
    main()
