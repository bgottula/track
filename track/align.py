#!/usr/bin/env python3

"""Perform automated alignment of a telescope mount.

This program automates the somewhat tedious process of aligning the mount. It will do the following
things:
1) Generate a list of positions on the sky to point at
2) For each position:
   a) Point the mount at the position
   b) Capture an image with a camera
   c) Use the astrometry.net plate solver to determine the sky coordinates of the image
   d) Store a timestamp and the mount's encoder positions
3) Use the set of observations to solve for mount model parameters
4) Store the mount model parameters on disk for future use during the same observing session
"""

import sys
import time
import numpy as np
import pandas as pd
from typing import List, Optional
from astropy_healpix import HEALPix
from astropy import units as u
from astropy.time import Time
from astropy.coordinates import SkyCoord, EarthLocation, Angle
from astroplan import Observer
import cv2
import asi
import track
from track.model import ModelParamSet
from track.mounts import MeridianSide


def alt_from_ha_dec(ha, dec, mount_pole_altitude):
    """Get the approximate altitude of a target specified with a local hour angle and declination.

    Args:
        ha: Target local hour angle as an astropy Angle object.
        dec: Target declination as an astropy Angle object.
        mount_pole_altitude: Altitude of the mount's pole in degrees above the horizon.

    Returns:
        The altitude of the target as an astropy Angle object.
    """

    # This is a fake location required in order to determine the altitude of each HEALPix pixel.
    # In these conversions, which only need to be approximate, the longitude and elevation of the
    # observer don't matter. The "latitude" is set to the altitude of the mount's pole since our
    # HEALPix hour angles and declinations are relative to the mount's pole location and not the
    # celestial pole.
    location = EarthLocation(lat=mount_pole_altitude*u.deg, lon=0*u.deg, height=0*u.m)

    # The time should be relatively unimportant for these calculations; it is only necessary
    # because astropy does not provide a direct transformation between local coordinates given as
    # hour angle / declination and local coordinates in azimuth / altitude format. Therefore, we
    # must transform first to equatorial coordinates (right ascension / declination) before
    # converting finally to azimuth / altitude.
    t = Time(time.time(), format='unix', location=location)
    st = t.sidereal_time('mean')
    ra = st - ha
    me = Observer(location=location)
    sc = SkyCoord(ra, dec, frame='icrs')
    return me.altaz(t, target=sc).alt


def generate_positions(
        min_positions: int,
        mount_pole_altitude: Angle,
        min_altitude: Angle = 0.0*u.deg,
        meridian_side: Optional[MeridianSide] = None
    ) -> List[SkyCoord]:
    """Generate a list of equally spaced positions on the sky to search.

    The list of positions generated will be a subset of pixels generated by the HEALPix algorithm,
    which is a method of pixelization of a sphere where each "pixel" has equal area. In the
    context of mount alignment we not so much concerned with the equal area property, but we do
    want positions that are roughly evenly distributed over the sphere, and HEALPix does a
    reasonable job of this as well. The full set of HEALPix pixels is filtered to exclude pixels
    that are below a minimum altitude threshold and (optionally) those that are on the opposite
    side of the meridian. HEALPix is oriented with the top co-located with the pole of the mount.

    Args:
        min_positions: Minimum number of positions. The actual number of positions returned may be
            larger than requested.
        mount_pole_altitude: Altitude of the mount's pole. For a German equatorial mount in the
            Northern hemisphere this is usually equal to the current latitude, however it is valid
            for the mount pole to have a different altitude.
        min_altitude: Restrict positions to be above this altitude.
        meridian_side: If specified, restricts positions to only be on this side of the meridian,
            where meridian is defined as the great circle passing through local zenith and the
            mount pole.

    Returns:
        A list of SkyCoord objects with the set of positions to be searched during alignment.
        Since this is used for alignment and no assumptions are made about the orientation
        of the mount, particularly the location of the mount's pole, these coordinates are
        interpreted with respect to the mount's startup position. In other words, declination
        0 means the optical tube is pointed towards the mount's physical pole, and not
        necessarily towards Polaris. Similarly, hour angle 0 means that the counter weight is
        pointed down, and this does not necessarily correspond to the great circle passing
        through the local zenith and the celestial pole.
    """
    level = 0
    while True:
        healpix = HEALPix(nside=2**level)
        positions = []
        for i in range(healpix.npix):

            # interpret each HEALPix as an hour angle and declination coordinate
            (ha, dec) = healpix.healpix_to_lonlat(i)

            # skip points on wrong side of meridian
            if ha <= 180*u.deg and meridian_side == MeridianSide.EAST:
                continue

            if ha > 180*u.deg and meridian_side == MeridianSide.WEST:
                continue

            # skip points below min altitude threshold
            alt = alt_from_ha_dec(ha, dec, mount_pole_altitude)
            if alt < min_altitude:
                continue

            positions.append(SkyCoord(ha, dec))

        if len(positions) >= min_positions:
            break

        # not enough positions -- try again with a higher level HEALPix
        level += 1

    return positions


def main():
    """Run the alignment procedure! See module docstring for a description."""

    parser = track.ArgParser()
    parser.add_argument(
        '--mount-type',
        help='select mount type (nexstar or gemini)',
        default='gemini'
    )
    parser.add_argument(
        '--mount-path',
        help='serial device node or hostname for mount command interface',
        default='/dev/ttyACM0'
    )
    parser.add_argument(
        '--meridian-side',
        help='side of meridian for equatorial mounts to prefer',
        default='west'
    )
    parser.add_argument(
        '--lat',
        required=True,
        help='latitude of observer (+N)'
    )
    parser.add_argument(
        '--lon',
        required=True,
        help='longitude of observer (+E)'
    )
    parser.add_argument(
        '--elevation',
        required=True,
        help='elevation of observer (m)',
        type=float
    )
    parser.add_argument(
        '--mount-pole-alt',
        required=True,
        help='altitude of mount pole above horizon (deg)',
        type=float
    )
    parser.add_argument(
        '--loop-bw',
        help='control loop bandwidth (Hz)',
        default=0.5,
        type=float
    )
    parser.add_argument(
        '--loop-damping',
        help='control loop damping factor',
        default=2.0,
        type=float
    )
    parser.add_argument(
        '--telem-enable',
        help='enable logging of telemetry to database',
        action='store_true'
    )
    parser.add_argument(
        '--telem-db-host',
        help='hostname of InfluxDB database server',
        default='localhost'
    )
    parser.add_argument(
        '--telem-db-port',
        help='port number of InfluxDB database server',
        default=8086,
        type=int
    )
    parser.add_argument(
        '--telem-period',
        help='telemetry sampling period in seconds',
        default=1.0,
        type=float
    )
    parser.add_argument(
        '--min-positions',
        help='minimum number of positions to add to mount alignment model',
        default=10,
        type=int
    )
    parser.add_argument(
        '--timeout',
        help='max time to wait for mount to converge on a new position',
        default=120.0,
        type=float
    )
    parser.add_argument(
        '--max-tries',
        help='max number of plate solving attempts at each position',
        default=3,
        type=int
    )
    parser.add_argument(
        '--min-alt',
        help='minimum altitude of alignment positions in degrees',
        default=20.0,
        type=float
    )
    parser.add_argument(
        '--laser-ftdi-serial',
        help='serial number of laser pointer FTDI device',
    )
    cameras.add_program_arguments(parser)
    args = parser.parse_args()

    # This program only supports Gemini mounts
    # TODO: Abstract Gemini-specific code
    if args.mount_type == 'gemini':
        mount = track.LosmandyGeminiMount(args.mount_path)
    else:
        print('mount-type not supported: ' + args.mount_type)
        sys.exit(1)

    # Create object with base type ErrorSource. No target for now; that will be populated later.
    error_source = track.BlindErrorSource(
        mount=mount,
        mount_model=None,  # FIXME!
        target=None,
        meridian_side=args.meridian_side
    )
    telem_sources = {'error_blind': error_source}

    try:
        laser = track.LaserPointer(serial_num=args.laser_ftdi_serial)
    except OSError:
        print('Could not connect to laser pointer FTDI device.')
        laser = None

    try:
        # Create gamepad object and register callback
        game_pad = track.Gamepad(
            left_gain=2.0,  # left stick degrees per second
            right_gain=0.5,  # right stick degrees per second
            int_limit=5.0,  # max correction in degrees for either axis
        )
        game_pad.integrator_mode = True
        if laser is not None:
            game_pad.register_callback('BTN_SOUTH', laser.set)
        telem_sources['gamepad'] = game_pad
        print('Gamepad found and registered.')
    except RuntimeError:
        print('No gamepads found.')

    tracker = track.Tracker(
        mount=mount,
        error_source=error_source,
        loop_bandwidth=args.loop_bw,
        damping_factor=args.loop_damping
    )
    telem_sources['tracker'] = tracker
    tracker.stop_on_timer = True
    tracker.max_run_time = args.timeout
    tracker.stop_when_converged = True
    tracker.converge_max_error_mag = 2.0

    camera = cameras.make_camera_from_args(args)

    if args.telem_enable:
        telem_logger = track.TelemLogger(
            host=args.telem_db_host,
            port=args.telem_db_port,
            period=args.telem_period,
            sources=telem_sources,
        )
        telem_logger.start()

    positions = generate_positions(
        min_positions=args.min_positions,
        mount_pole_altitude=args.mount_pole_alt,
        min_altitude=args.min_alt,
        meridian_side=args.meridian_side
    )

    # pylint: disable=broad-except
    try:
        observations = pd.DataFrame(columns=[
            'unix_timestamp',
            'encoder_0',
            'encoder_1',
            'sky_ra',
            'sky_dec'
        ])
        num_solutions = 0
        for idx, position in enumerate(positions):

            print('Moving to position {} of {}: {}'.format(idx, len(positions), str(position)))

            error_source.target = FixedTarget(position)
            stop_reason = tracker.run()
            mount.safe()
            if stop_reason != 'converged':
                raise RuntimeError('Unexpected tracker stop reason: "{}"'.format(stop_reason))

            print('Converged on the target position. Attempting plate solving.')

            # plate solver doesn't always work on the first try
            for i in range(args.max_tries):

                print('\tPlate solver attempt {} of {}...'.format(i + 1, args.max_tries), end='')

                timestamp = time.time()
                frame = camera.get_frame()

                try:
                    sc = track.plate_solve(
                        frame,
                        camera_width=camera.field_of_view[1]
                    )
                    print('Solution found!')
                    mount_position = mount.get_position()
                    observations.append({
                        'unix_timestamp': timestamp,
                        'encoder_0': mount_position['pra'],
                        'encoder_1': mount_position['pdec'],
                        'sky_ra': sc.ra.deg,
                        'sky_dec': sc.dec.deg,
                    })
                    num_solutions += 1
                    break
                except track.NoSolutionException:
                    print('No solution.')

        print('Plate solver found solutions at {} of {} positions.'.format(
            num_solutions,
            len(positions)
        ))

        location = EarthLocation(lat=args.lat*u.deg, lon=args.lon*u.deg, height=args.elevation*u.m)
        try:
            print('Solving for mount model parameters...', end='')
            model_params = track.model.solve_model(observations, location)
            model_param_set = ModelParamSet(
                model_params=model_params,
                location=location,
                timestamp=time.time(),
            )
            print('success!')
            filename = track.model.DEFAULT_MODEL_FILENAME
            print('Saving model parameters to {}'.format(filename))
            track.model.save_default_model(model_param_set)
        except track.model.NoSolutionException as e:
            print('failed: {}'.format(str(e)))

    except RuntimeError as e:
        print(str(e))
        print('Alignment was not completed.')
    except KeyboardInterrupt:
        print('Got CTRL-C, shutting down...')
    except Exception as e:
        print('Unhandled exception: ' + str(e))
    finally:
        # don't rely on destructors to safe mount!
        print('Safing mount...')
        if mount.safe():
            print('Mount safed successfully!')
        else:
            print('Warning: Mount may be in an unsafe state!')

    if args.telem_enable:
        telem_logger.stop()

    try:
        game_pad.stop()
    # pylint: disable=bare-except
    except:
        pass

if __name__ == "__main__":
    main()
